#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           base_fr,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           base_br,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           base_bl,       tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           base_fl,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lift_r,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           lift_l,        tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"

#define AUTO_ZONE 20

#define LEFT_SIDE

#if AUTO_ZONE != 5 && AUTO_ZONE != 20
#error "AUTO_ZONE must be defined as 5 or 20"
#endif

void drive(int power);
void drive_left(int power);
void drive_right(int power);
void drive_enc(int enc, int power);
void drive_enc_stop(int enc, int power);
int base_enc();
void base_reset();
void lift(int power);
void init_lcd();
void update_lcd();
void piano();

void pre_auton() {
    base_reset();
}

long time;

task autonomous() {
    clearTimer(T1);
    drive_enc_stop(3000, 127);
    lift(127);
    sleep(200);
    lift(20);
    sleep(100);
    lift(0);
    drive_enc_stop(-base_enc(), -127);
    sleep(200);
    #if AUTO_ZONE == 5
        lift(-127);
        sleep(500);
        lift(0);
        base_reset();
        #ifdef LEFT_SIDE
            drive_left(-127);
            while (nMotorEncoder(base_bl) > -600);
            drive_left(0);
        #else
            drive_right(-127);
            while (nMotorEncoder(base_br) > -600);
            drive_right(0);
        #endif
        drive_enc_stop(-100, -127);
    #else
        base_reset();
	    #ifdef LEFT_SIDE
            drive_left(127);
            while (nMotorEncoder(base_bl) < 2250);
            drive_left(0);
        #else
            drive_right(127);
            while (nMotorEncoder(base_br) < 2250);
            drive_right(0);
        #endif
	    drive_enc_stop(700, 127);
	    sleep(200);
	    base_reset();
	    #ifdef LEFT_SIDE
            drive_left(127);
            while (nMotorEncoder(base_bl) < 650);
            drive_left(0);
        #else
            drive_right(127);
            while (nMotorEncoder(base_br) < 650);
            drive_right(0);
        #endif
	    sleep(200);
	    drive_enc(400, 127);
	    lift(127);
	    drive_enc(1200, 127);
	    lift(0);
	    drive_enc_stop(-1200, -127);
	    lift(-127);
	    sleep(1000);
	    lift(0);
	    time = time1[T1];
    #endif
}

task usercontrol() {
    init_lcd();
    while (1) {
        motor[lift_l] = motor[lift_r] =
            vexRT[Btn6U] ? 127 :
            vexRT[Btn6D] ? -127 :
            vexRT[Btn8U] ? 10 : 0;
        drive_left(vexRT[Ch3]);
        drive_right(vexRT[Ch2]);
        if (vexRT[Btn7U]) {
            motor[port8] = 100;
            motor[port9] = -100;
        } else if (vexRT[Btn7D]) {
            motor[port8] = -100;
            motor[port9] = 100;
        } else {
            motor[port8] = motor[port9] = 0;
        }
        update_lcd();
        piano();
    }
}

void drive(int power) {
    drive_left(power);
    drive_right(power * 115 / 127);
}

void drive_left(int power) {
    motor[base_fl] = motor[base_bl] = power;
}

void drive_right(int power) {
    motor[base_fr] = motor[base_br] = power;
}

void drive_enc(int enc, int power) {
    base_reset();
    drive(power);
    if (power > 0)
        while (base_enc() < enc);
    else
        while (base_enc() > enc);
}

void drive_enc_stop(int enc, int power) {
    drive_enc(enc, power);
    drive(0);
}

int base_enc() {
    return (nMotorEncoder(base_bl) + nMotorEncoder(base_br)) / 2;
}

void base_reset() {
    resetMotorEncoder(base_fr);
    resetMotorEncoder(base_br);
    resetMotorEncoder(base_bl);
    resetMotorEncoder(base_fl);
}

void lift(int power) {
    motor[lift_l] = motor[lift_r] = power;
}

void init_lcd() {
    clearLCDLine(0);
    clearLCDLine(1);
    displayLCDString(0, 0, "BATTERY X.XX V  ");
}

void update_lcd() {
    static string s;
	sprintf(s, "%1.2f", nImmediateBatteryLevel * 0.001);
	displayLCDString(0, 8, s);
}

void piano() {
    static int previous = 0;
    int current = nLCDButtons;
    if (previous != current) {
        switch (current) {
            case 1:
	            playImmediateTone(523, 1000);
	            break;
	        case 2:
	            playImmediateTone(587, 1000);
	            break;
	        case 4:
	            playImmediateTone(659, 1000);
	            break;
	        case 3:
	            playImmediateTone(698, 1000);
	            break;
	        case 6:
	            playImmediateTone(784, 1000);
	            break;
	        case 5:
	            playImmediateTone(880, 1000);
	            break;
	        case 7:
	            playImmediateTone(988, 1000);
	            break;
	        case 0:
	            clearSounds();
	            break;
	    }
	}
	previous = current;
}
